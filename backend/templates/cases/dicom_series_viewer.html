{% extends 'base.html' %}
{% load static %}

{% block title %}CBCT Series Viewer - {{ case.case_number }} - DCPlant{% endblock %}

{% block extra_css %}
<style>
    #dicomViewer {
        width: 100%;
        height: 700px;
        background-color: black;
        position: relative;
        cursor: crosshair;
    }
    
    .viewer-controls {
        background: #2c3e50;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 15px;
    }
    
    .viewer-controls .btn {
        margin: 0 5px;
    }
    
    .slice-controls {
        background: #34495e;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 10px;
        color: white;
    }
    
    .slice-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    #sliceSlider {
        width: 100%;
    }
    
    .viewer-info {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        height: 700px;
        overflow-y: auto;
    }
    
    .tool-active {
        background-color: #007bff !important;
        color: white !important;
    }
    
    #loadingIndicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 1.2rem;
        z-index: 1000;
    }
    
    .progress-bar-container {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 80%;
        z-index: 999;
    }
    
    .viewport-orientation {
        position: absolute;
        color: white;
        font-size: 14px;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }
    
    .orientation-top { top: 10px; left: 50%; transform: translateX(-50%); }
    .orientation-bottom { bottom: 10px; left: 50%; transform: translateX(-50%); }
    .orientation-left { left: 10px; top: 50%; transform: translateY(-50%); }
    .orientation-right { right: 10px; top: 50%; transform: translateY(-50%); }
    
    .mpr-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-gap: 10px;
        height: 700px;
    }
    
    .mpr-viewport {
        background: black;
        position: relative;
        border: 2px solid #34495e;
    }
    
    .mpr-label {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-weight: bold;
        background: rgba(0,0,0,0.5);
        padding: 5px 10px;
        border-radius: 3px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb mb-2">
                    <li class="breadcrumb-item"><a href="{% url 'cases:case_list' %}">Cases</a></li>
                    <li class="breadcrumb-item"><a href="{% url 'cases:case_detail' case.pk %}">{{ case.case_number }}</a></li>
                    <li class="breadcrumb-item active">CBCT Series Viewer</li>
                </ol>
            </nav>
            <h1><i class="bi bi-stack me-2"></i>CBCT Series Viewer</h1>
            <p class="text-muted mb-0">{{ case.patient.full_name }} - {{ total_slices }} slices</p>
        </div>
        <div>
            <a href="{% url 'cases:case_detail' case.pk %}" class="btn btn-outline-primary">
                <i class="bi bi-arrow-left"></i> Back to Case
            </a>
        </div>
    </div>

    <!-- Viewer Controls -->
    <div class="viewer-controls">
        <div class="row">
            <div class="col-md-6">
                <div class="btn-group" role="group">
                    <button class="btn btn-outline-light tool-btn" data-tool="wwwc" title="Window/Level">
                        <i class="bi bi-brightness-high"></i> W/L
                    </button>
                    <button class="btn btn-outline-light tool-btn" data-tool="pan" title="Pan">
                        <i class="bi bi-arrows-move"></i> Pan
                    </button>
                    <button class="btn btn-outline-light tool-btn" data-tool="zoom" title="Zoom">
                        <i class="bi bi-zoom-in"></i> Zoom
                    </button>
                    <button class="btn btn-outline-light tool-btn" data-tool="length" title="Measure">
                        <i class="bi bi-rulers"></i> Measure
                    </button>
                    <button class="btn btn-outline-light tool-btn" data-tool="angle" title="Angle">
                        <i class="bi bi-triangle"></i> Angle
                    </button>
                    <button class="btn btn-outline-light tool-btn" data-tool="probe" title="Probe">
                        <i class="bi bi-crosshair"></i> Probe
                    </button>
                </div>
            </div>
            <div class="col-md-6 text-end">
                <button class="btn btn-outline-warning" onclick="resetViewport()">
                    <i class="bi bi-arrow-clockwise"></i> Reset
                </button>
                <button class="btn btn-outline-info" onclick="toggleMPR()">
                    <i class="bi bi-grid-3x3"></i> MPR View
                </button>
                <button class="btn btn-outline-success" onclick="playStack()">
                    <i class="bi bi-play-fill"></i> Play
                </button>
            </div>
        </div>
    </div>

    <!-- Slice Controls -->
    <div class="slice-controls">
        <div class="slice-info">
            <span>Slice: <strong id="currentSlice">1</strong> / {{ total_slices }}</span>
            <span>Use mouse wheel to scroll through slices</span>
            <span id="sliceLocation"></span>
        </div>
        <input type="range" class="form-range" id="sliceSlider" min="0" max="{{ total_slices|add:'-1' }}" value="0">
        <div class="progress mt-2" style="height: 5px;">
            <div class="progress-bar bg-info" id="loadProgress" style="width: 0%"></div>
        </div>
    </div>

    <!-- Main Viewer Area -->
    <div class="row">
        <div class="col-lg-9">
            <div id="viewerContainer">
                <!-- Standard View -->
                <div id="standardView">
                    <div id="dicomViewer">
                        <div id="loadingIndicator">
                            <div class="spinner-border text-light" role="status">
                                <span class="visually-hidden">Loading CBCT series...</span>
                            </div>
                            <p class="mt-2">Loading {{ total_slices }} slices...</p>
                        </div>
                        <!-- Orientation markers -->
                        <div class="viewport-orientation orientation-top">A</div>
                        <div class="viewport-orientation orientation-bottom">P</div>
                        <div class="viewport-orientation orientation-left">R</div>
                        <div class="viewport-orientation orientation-right">L</div>
                    </div>
                </div>
                
                <!-- MPR View (hidden by default) -->
                <div id="mprView" style="display: none;">
                    <div class="mpr-container">
                        <div class="mpr-viewport" id="axialViewport">
                            <div class="mpr-label">Axial</div>
                        </div>
                        <div class="mpr-viewport" id="sagittalViewport">
                            <div class="mpr-label">Sagittal</div>
                        </div>
                        <div class="mpr-viewport" id="coronalViewport">
                            <div class="mpr-label">Coronal</div>
                        </div>
                        <div class="mpr-viewport" id="3dViewport">
                            <div class="mpr-label">3D</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-lg-3">
            <div class="viewer-info">
                <h5 class="mb-3">Series Information</h5>
                <dl class="row">
                    <dt class="col-sm-5">Patient:</dt>
                    <dd class="col-sm-7">{{ case.patient.full_name }}</dd>
                    
                    <dt class="col-sm-5">Case:</dt>
                    <dd class="col-sm-7">{{ case.case_number }}</dd>
                    
                    <dt class="col-sm-5">Total Slices:</dt>
                    <dd class="col-sm-7">{{ total_slices }}</dd>
                    
                    <dt class="col-sm-5">Modality:</dt>
                    <dd class="col-sm-7" id="modality">CBCT</dd>
                    
                    <dt class="col-sm-5">Study Date:</dt>
                    <dd class="col-sm-7" id="studyDate">-</dd>
                    
                    <dt class="col-sm-5">Slice Thickness:</dt>
                    <dd class="col-sm-7" id="sliceThickness">-</dd>
                    
                    <dt class="col-sm-5">Pixel Spacing:</dt>
                    <dd class="col-sm-7" id="pixelSpacing">-</dd>
                </dl>
                
                <hr>
                
                <h6>Window Presets</h6>
                <div class="d-grid gap-2">
                    <button class="btn btn-sm btn-outline-secondary" onclick="setWindowPreset('bone')">
                        Bone
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="setWindowPreset('soft')">
                        Soft Tissue
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="setWindowPreset('lung')">
                        Lung
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="setWindowPreset('dental')">
                        Dental
                    </button>
                </div>
                
                <hr>
                
                <h6>Measurements</h6>
                <div id="measurements" class="small">
                    <p class="text-muted">No measurements yet</p>
                </div>
                
                <hr>
                
                <h6>Keyboard Shortcuts</h6>
                <small class="text-muted">
                    <kbd>↑/↓</kbd> Navigate slices<br>
                    <kbd>Mouse Wheel</kbd> Scroll slices<br>
                    <kbd>Space</kbd> Play/Pause<br>
                    <kbd>R</kbd> Reset view<br>
                    <kbd>M</kbd> Toggle MPR
                </small>
            </div>
        </div>
    </div>
</div>

<!-- Include Cornerstone.js libraries -->
<script src="https://unpkg.com/cornerstone-core@2.6.1/dist/cornerstone.min.js"></script>
<script src="https://unpkg.com/cornerstone-math@0.1.10/dist/cornerstoneMath.min.js"></script>
<script src="https://unpkg.com/cornerstone-tools@6.0.0/dist/cornerstoneTools.min.js"></script>
<script src="https://unpkg.com/cornerstone-wado-image-loader@4.1.5/dist/cornerstoneWADOImageLoader.bundle.min.js"></script>
<script src="https://unpkg.com/dicom-parser@1.8.21/dist/dicomParser.min.js"></script>
<script src="https://unpkg.com/hammerjs@2.0.8/hammer.min.js"></script>

<script>
// Configure Cornerstone
cornerstoneWADOImageLoader.external.cornerstone = cornerstone;
cornerstoneWADOImageLoader.external.dicomParser = dicomParser;
cornerstoneTools.external.cornerstone = cornerstone;
cornerstoneTools.external.Hammer = Hammer;
cornerstoneTools.external.cornerstoneMath = cornerstoneMath;

// Initialize
cornerstoneTools.init();

// Get DOM elements first
const element = document.getElementById('dicomViewer');
const sliceSlider = document.getElementById('sliceSlider');

// Stack state
let stack = {
    currentImageIdIndex: 0,
    imageIds: []
};
let isPlaying = false;
let playInterval;

// Prepare image URLs
const imageUrls = {{ image_urls|safe }};
const totalSlices = {{ total_slices }};

// Convert URLs to Cornerstone image IDs
imageUrls.forEach(url => {
    // Create full URL
    const fullUrl = window.location.origin + url;
    const imageId = 'wadouri:' + fullUrl;
    stack.imageIds.push(imageId);
});

// Initialize viewer after DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    initializeViewer();
});

function initializeViewer() {
    // Enable the viewport
    cornerstone.enable(element);

    // Set up stack scrolling
    const StackScrollMouseWheelTool = cornerstoneTools.StackScrollMouseWheelTool;
    cornerstoneTools.addTool(StackScrollMouseWheelTool);
    cornerstoneTools.setToolActive('StackScrollMouseWheel', {});

    // Add other tools
    cornerstoneTools.addTool(cornerstoneTools.WwwcTool);
    cornerstoneTools.addTool(cornerstoneTools.PanTool);
    cornerstoneTools.addTool(cornerstoneTools.ZoomTool);
    cornerstoneTools.addTool(cornerstoneTools.LengthTool);
    cornerstoneTools.addTool(cornerstoneTools.AngleTool);
    cornerstoneTools.addTool(cornerstoneTools.ProbeTool);

    // Set default tool
    cornerstoneTools.setToolActive('Wwwc', { mouseButtonMask: 1 });

    // Load and display the first image
    loadAndDisplayImage(0);

    // Tool button handlers
    document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const tool = this.dataset.tool;
            
            // Remove active class from all buttons
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('tool-active'));
            this.classList.add('tool-active');
            
            // Deactivate all tools
            cornerstoneTools.setToolPassive('Wwwc');
            cornerstoneTools.setToolPassive('Pan');
            cornerstoneTools.setToolPassive('Zoom');
            cornerstoneTools.setToolPassive('Length');
            cornerstoneTools.setToolPassive('Angle');
            cornerstoneTools.setToolPassive('Probe');
            
            // Activate selected tool
            const toolMap = {
                'wwwc': 'Wwwc',
                'pan': 'Pan',
                'zoom': 'Zoom',
                'length': 'Length',
                'angle': 'Angle',
                'probe': 'Probe'
            };
            
            if (toolMap[tool]) {
                cornerstoneTools.setToolActive(toolMap[tool], { mouseButtonMask: 1 });
            }
        });
    });

    // Slice slider handler
    sliceSlider.addEventListener('input', function() {
        const index = parseInt(this.value);
        loadAndDisplayImage(index);
    });
}

// Load and display image function
function loadAndDisplayImage(index) {
    if (index < 0 || index >= stack.imageIds.length) return;
    
    stack.currentImageIdIndex = index;
    const imageId = stack.imageIds[index];
    
    // Update UI
    document.getElementById('currentSlice').textContent = index + 1;
    sliceSlider.value = index;
    
    // Load progress
    const progress = ((index + 1) / totalSlices) * 100;
    document.getElementById('loadProgress').style.width = progress + '%';
    
    // Update MPR views if enabled
    if (mprEnabled) {
        updateMPRViews();
    }
    
    // Load and display image
    cornerstone.loadAndCacheImage(imageId).then(function(image) {
        cornerstone.displayImage(element, image);
        
        // Hide loading indicator after first image
        const loadingIndicator = document.getElementById('loadingIndicator');
        if (loadingIndicator) {
            loadingIndicator.style.display = 'none';
        }
        
        // Update metadata if available
        updateMetadata(imageId);
    }).catch(function(err) {
        console.error('Error loading image:', err);
    });
}

// Update metadata display
function updateMetadata(imageId) {
    try {
        const metadata = cornerstoneWADOImageLoader.metaData.get('imagePlaneModule', imageId) || {};
        const patientModule = cornerstoneWADOImageLoader.metaData.get('patientModule', imageId) || {};
        const studyModule = cornerstoneWADOImageLoader.metaData.get('generalStudyModule', imageId) || {};
        
        if (studyModule.studyDate) {
            document.getElementById('studyDate').textContent = studyModule.studyDate;
        }
        
        if (metadata.sliceThickness) {
            document.getElementById('sliceThickness').textContent = metadata.sliceThickness + ' mm';
        }
        
        if (metadata.pixelSpacing) {
            document.getElementById('pixelSpacing').textContent = 
                metadata.pixelSpacing[0].toFixed(2) + ' x ' + metadata.pixelSpacing[1].toFixed(2) + ' mm';
        }
        
        if (metadata.sliceLocation) {
            document.getElementById('sliceLocation').textContent = 
                'Location: ' + metadata.sliceLocation.toFixed(2) + ' mm';
        }
    } catch (e) {
        console.log('Metadata not available');
    }
}

// Keyboard navigation
document.addEventListener('keydown', function(e) {
    switch(e.key) {
        case 'ArrowUp':
            if (stack.currentImageIdIndex > 0) {
                loadAndDisplayImage(stack.currentImageIdIndex - 1);
            }
            break;
        case 'ArrowDown':
            if (stack.currentImageIdIndex < stack.imageIds.length - 1) {
                loadAndDisplayImage(stack.currentImageIdIndex + 1);
            }
            break;
        case ' ':
            e.preventDefault();
            playStack();
            break;
        case 'r':
        case 'R':
            resetViewport();
            break;
        case 'm':
        case 'M':
            toggleMPR();
            break;
    }
});

// Mouse wheel navigation
element.addEventListener('wheel', function(e) {
    e.preventDefault();
    if (e.deltaY > 0) {
        // Scroll down - next slice
        if (stack.currentImageIdIndex < stack.imageIds.length - 1) {
            loadAndDisplayImage(stack.currentImageIdIndex + 1);
        }
    } else {
        // Scroll up - previous slice
        if (stack.currentImageIdIndex > 0) {
            loadAndDisplayImage(stack.currentImageIdIndex - 1);
        }
    }
});

// Play stack animation
function playStack() {
    if (isPlaying) {
        // Stop playing
        clearInterval(playInterval);
        isPlaying = false;
        document.querySelector('[onclick="playStack()"] i').classList.replace('bi-pause-fill', 'bi-play-fill');
    } else {
        // Start playing
        isPlaying = true;
        document.querySelector('[onclick="playStack()"] i').classList.replace('bi-play-fill', 'bi-pause-fill');
        
        playInterval = setInterval(function() {
            if (stack.currentImageIdIndex < stack.imageIds.length - 1) {
                loadAndDisplayImage(stack.currentImageIdIndex + 1);
            } else {
                // Loop back to start
                loadAndDisplayImage(0);
            }
        }, 100); // 10 fps
    }
}

// Reset viewport
function resetViewport() {
    cornerstone.reset(element);
}

// Window presets
function setWindowPreset(preset) {
    const viewport = cornerstone.getViewport(element);
    
    const presets = {
        'bone': { ww: 2000, wc: 300 },
        'soft': { ww: 400, wc: 40 },
        'lung': { ww: 1500, wc: -600 },
        'dental': { ww: 2800, wc: 1000 }
    };
    
    if (presets[preset]) {
        viewport.voi.windowWidth = presets[preset].ww;
        viewport.voi.windowCenter = presets[preset].wc;
        cornerstone.setViewport(element, viewport);
    }
}

// Toggle MPR view
let mprViewports = {};
let mprEnabled = false;

function toggleMPR() {
    const standardView = document.getElementById('standardView');
    const mprView = document.getElementById('mprView');
    const mprButton = document.querySelector('[onclick="toggleMPR()"]');
    
    if (mprView.style.display === 'none') {
        // Enable MPR view
        standardView.style.display = 'none';
        mprView.style.display = 'block';
        mprEnabled = true;
        mprButton.classList.add('btn-info');
        mprButton.classList.remove('btn-outline-info');
        
        // Initialize MPR viewports
        initializeMPRViewports();
    } else {
        // Disable MPR view
        standardView.style.display = 'block';
        mprView.style.display = 'none';
        mprEnabled = false;
        mprButton.classList.remove('btn-info');
        mprButton.classList.add('btn-outline-info');
    }
}

function initializeMPRViewports() {
    // Initialize viewports for each orientation
    const viewportIds = ['axialViewport', 'sagittalViewport', 'coronalViewport', '3dViewport'];
    
    viewportIds.forEach(viewportId => {
        const viewportElement = document.getElementById(viewportId);
        
        // Enable the viewport if not already enabled
        if (!mprViewports[viewportId]) {
            cornerstone.enable(viewportElement);
            mprViewports[viewportId] = viewportElement;
            
            // Add mouse wheel scrolling for each viewport
            viewportElement.addEventListener('wheel', function(e) {
                e.preventDefault();
                handleMPRScroll(viewportId, e.deltaY);
            });
        }
    });
    
    // Load initial images in each viewport
    updateMPRViews();
}

function updateMPRViews() {
    if (!mprEnabled || !stack || !stack.imageIds) return;
    
    const currentIndex = stack.currentImageIdIndex || 0;
    
    // Axial view (standard horizontal slices)
    if (mprViewports['axialViewport']) {
        cornerstone.loadAndCacheImage(stack.imageIds[currentIndex]).then(image => {
            cornerstone.displayImage(mprViewports['axialViewport'], image);
            
            // Apply dental window preset
            const viewport = cornerstone.getViewport(mprViewports['axialViewport']);
            viewport.voi.windowWidth = 2800;
            viewport.voi.windowCenter = 1000;
            cornerstone.setViewport(mprViewports['axialViewport'], viewport);
        });
    }
    
    // Sagittal view (side view - would need reconstruction)
    if (mprViewports['sagittalViewport']) {
        // For true sagittal, we'd need to reconstruct from the volume
        // For now, show a different slice as placeholder
        const sagittalIndex = Math.min(currentIndex + Math.floor(stack.imageIds.length / 4), stack.imageIds.length - 1);
        cornerstone.loadAndCacheImage(stack.imageIds[sagittalIndex]).then(image => {
            cornerstone.displayImage(mprViewports['sagittalViewport'], image);
            
            // Apply rotation for sagittal view simulation
            const viewport = cornerstone.getViewport(mprViewports['sagittalViewport']);
            viewport.rotation = 90;
            viewport.voi.windowWidth = 2800;
            viewport.voi.windowCenter = 1000;
            cornerstone.setViewport(mprViewports['sagittalViewport'], viewport);
        });
    }
    
    // Coronal view (front view - would need reconstruction)
    if (mprViewports['coronalViewport']) {
        // For true coronal, we'd need to reconstruct from the volume
        // For now, show a different slice as placeholder
        const coronalIndex = Math.min(currentIndex + Math.floor(stack.imageIds.length / 2), stack.imageIds.length - 1);
        cornerstone.loadAndCacheImage(stack.imageIds[coronalIndex]).then(image => {
            cornerstone.displayImage(mprViewports['coronalViewport'], image);
            
            // Apply flip for coronal view simulation
            const viewport = cornerstone.getViewport(mprViewports['coronalViewport']);
            viewport.hflip = true;
            viewport.voi.windowWidth = 2800;
            viewport.voi.windowCenter = 1000;
            cornerstone.setViewport(mprViewports['coronalViewport'], viewport);
        });
    }
    
    // 3D view placeholder (would need volume rendering)
    if (mprViewports['3dViewport']) {
        // Show MIP (Maximum Intensity Projection) as a simple 3D representation
        const midIndex = Math.floor(stack.imageIds.length / 2);
        cornerstone.loadAndCacheImage(stack.imageIds[midIndex]).then(image => {
            cornerstone.displayImage(mprViewports['3dViewport'], image);
            
            const viewport = cornerstone.getViewport(mprViewports['3dViewport']);
            viewport.voi.windowWidth = 3500;
            viewport.voi.windowCenter = 1500;
            viewport.invert = false;
            cornerstone.setViewport(mprViewports['3dViewport'], viewport);
        });
    }
}

function handleMPRScroll(viewportId, delta) {
    if (!mprEnabled) return;
    
    // Determine scroll direction
    const scrollDirection = delta > 0 ? 1 : -1;
    
    // Update the current index based on viewport
    if (viewportId === 'axialViewport') {
        const newIndex = stack.currentImageIdIndex + scrollDirection;
        if (newIndex >= 0 && newIndex < stack.imageIds.length) {
            stack.currentImageIdIndex = newIndex;
            updateMPRViews();
            // Update main viewer too
            document.getElementById('sliceSlider').value = newIndex;
            document.getElementById('currentSlice').textContent = newIndex + 1;
        }
    }
    // Additional viewport-specific scrolling logic can be added here
}

// Track measurements
element.addEventListener('cornerstonetoolsmeasurementadded', function(e) {
    updateMeasurements();
});

element.addEventListener('cornerstonetoolsmeasurementmodified', function(e) {
    updateMeasurements();
});

function updateMeasurements() {
    const measurementsDiv = document.getElementById('measurements');
    const toolState = cornerstoneTools.globalImageIdSpecificToolStateManager.saveToolState();
    
    let html = '';
    let measurementCount = 0;
    
    // Check for length measurements
    for (let imageId in toolState) {
        if (toolState[imageId].length && toolState[imageId].length.data) {
            toolState[imageId].length.data.forEach((measurement, index) => {
                measurementCount++;
                const length = measurement.length ? measurement.length.toFixed(2) : 'N/A';
                html += `<p>Length ${measurementCount}: ${length} mm</p>`;
            });
        }
        
        if (toolState[imageId].angle && toolState[imageId].angle.data) {
            toolState[imageId].angle.data.forEach((measurement, index) => {
                measurementCount++;
                const angle = measurement.rAngle ? (measurement.rAngle * 180 / Math.PI).toFixed(1) : 'N/A';
                html += `<p>Angle ${measurementCount}: ${angle}°</p>`;
            });
        }
    }
    
    if (measurementCount === 0) {
        html = '<p class="text-muted">No measurements yet</p>';
    }
    
    measurementsDiv.innerHTML = html;
}

// Preload all images for smooth scrolling
function preloadImages() {
    stack.imageIds.forEach((imageId, index) => {
        cornerstone.loadAndCacheImage(imageId).then(() => {
            const progress = ((index + 1) / totalSlices) * 100;
            console.log(`Loaded ${index + 1}/${totalSlices}`);
        }).catch(err => {
            console.error(`Error loading image ${index}:`, err);
        });
    });
}

// Start preloading after initial display
setTimeout(preloadImages, 1000);
</script>
{% endblock %}